@compileTimeOnly("enable macroparadise")
class MsgSchema extends StaticAnnotation {
  def macroTransform(annottees: Any*): Any = macro schemaMacro.schemaImpl2
}

/*
@compileTimeOnly("compile time only")
class schema extends StaticAnnotation {
  def macroTransform(annottees: Any*): Any = macro schemaMacro.schemaImpl
}*/

object schemaMacro {

  def schemaImpl2(c: whitebox.Context)(annottees: c.Expr[Any]*): c.Expr[Any] = {
    import c.universe._

    val result = annottees.map(_.tree).toList match {
      case q"$modsi class $tpname[..$tparams] $ctorMods(..$paramss) extends { ..$earlydefns } with ..$parents { $self => ..$stats }" :: Nil =>
        q"""$modsi class $tpname[..$tparams] $ctorMods(..$paramss) extends { ..$earlydefns } with ..$parents {
           $self => ..$stats
           lazy val schema = pretty(SchemaFactory.default.createSchema(getClass).toJson)
           def tryExtract(jsonString: String): Either[List[ValidationError], $tpname] = {
              implicit val context = ExtractionContext(SchemaFactory.default)
              val validInput = JsonMethods.parse(jsonString)
              extract[$tpname](validInput)
           }
        }"""
      case _ => c.abort(c.enclosingPosition, s"error! ${showRaw(annottees.map(_.tree).toList)}")
    }

    c.Expr[Any](result)
  }

  /*
  def schemaImpl(c: whitebox.Context)(annottees: c.Expr[Any]*): c.Expr[Any] = {
    import c.universe._

    def getAnnotationNames(mods: Modifiers): List[String] = mods match {
      case Modifiers(_,_, annots) =>
        annots collect { case Apply(Select(New(Ident(TypeName(fn))), _), _) => fn }
      case _ => List()
    }

    def getInnerClassesWithAnnots(stats: Seq[Trees#Tree]): Seq[(String, Seq[String])] = stats collect {
      case q"$modsi class $tpname[..$tparams] $ctorMods(..$paramss) extends { ..$earlydefns } with ..$parents { $self => ..$stats }" =>
        tpname.toString -> getAnnotationNames(modsi.asInstanceOf[Modifiers])
    }

    val result = annottees.map(_.tree).toList match {
      case q"$mods class $tpname[..$tparams] $ctorMods(..$paramss) extends { ..$earlydefns } with ..$parents { $self => ..$stats }" :: Nil =>

        val annotations = getAnnotationNames(mods.asInstanceOf[Modifiers])
        val innerMsgClasses = getInnerClassesWithAnnots(stats) filter (_._2.contains("Msg")) map {_._1}
        //val paramNames = paramss.collect{ case q"$modz val $tname: $tpt = $expr" => tname }

        //val isMessageContainer = annotations.contains("Description")
        //println(isMessageContainer)

        q"""$mods class $tpname[..$tparams] $ctorMods(..$paramss) extends { ..$earlydefns } with ..$parents {
            $self => ..$stats
        }"""
      case q"$mods object $tname extends { ..$earlydefns } with ..$parents { $self => ..$body }" :: Nil =>
        println(getInnerClassesWithAnnots(body) filter (_._2.contains("Msg")) map {_._1})
        q"""$mods object $tname extends { ..$earlydefns } with ..$parents {
          $self => ..$body
        }"""
      /*case q"package object $tname extends { ..$earlydefns } with ..$parents { $self => ..$stats }" :: Nil =>
        c.abort(c.enclosingPosition, s"package object found: $tname!")*/
      case q"$mods def $tname[..$tparams](...$paramss): $tpt = $expr" :: Nil =>
        //println(println(showRaw(c.prefix.tree)))
        val msgs = expr match {
          case Block(defs, _) =>
            val msf = defs collect {
              case q"$modsi class $tpname[..$tparams] $ctorMods(..$paramss) extends { ..$earlydefns } with ..$parents { $self => ..$stats }" => tpname.toString
            }
            msf
          case _ => List.empty[String]
        }
        q"""$mods def $tname[..$tparams](...$paramss): $tpt = {
               $expr
               val m = pretty(SchemaFactory.default.createSchema[${msgs.head}].toJson)
               println(m)
        }"""

      case q"""$mods val $tname: $tpt = $expr""" :: Nil =>
        val msgs = expr match {
          case Block(defs, _) =>
            val msf = defs collect {
              case q"$modsi class $tpname[..$tparams] $ctorMods(..$paramss) extends { ..$earlydefns } with ..$parents { $self => ..$stats }" => tpname.toString
            }
            msf
          case _ => List.empty[String]
        }
        println(msgs)
        q"""$mods val $tname: $tpt = {
           $expr

           println("LAZY")
        }"""

        //${typeNames.EMPTY}.this

      /*case q"(..$params) => $expr" :: Nil =>
        c.abort(c.enclosingPosition, s"method: $expr")*/
      case _ =>
        c.abort(c.enclosingPosition, s"error! ${showRaw(annottees.map(_.tree).toList)}")
    }
    c.Expr[Any](result)
  }
*/
}